# 객체 지향 프로그래밍(Objected-Oriented Programming)

1. 객체 지향 프로그래밍이란?

   - 프로그래밍에서 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체를 만들고 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍
   - 어떠한 기능을 제공하는 객체를 만들어 객체들을 조립하여 프로그래밍 하는 것
   - 객체는 상태(state)와 행위(behave)로 이루어져 있음
     > 상태와 행위란?

   ```
   Class Beverage {
       Private String name;
       Private String toppings;
       Private int cost;

       public String addTopping(String topping) {
           return toppings += topping;
       }
       public String drink() {
           return name + "을(를) 마셨습니다.";
       }
   }

   이러한 객체가 있을 때
   음료의 이름, 토핑, 가격은 상태(state)
   addTopping, drink와 같은 객체의 메소드를 행위(behavior)라 함
   ```

   - 객체가 가지는 기능은 적을수록 좋음
   - 어떠한 객체가 다른 객체를 이용하는 것을 의존성이라 하며, 객체의 의존성은 적을수록 좋음 -> 객체 하나를 수정할 때 의존관계의 객체도 영향을 받기 때문

2. 특징

   1. 클래스와 인스턴스(객체)

      - 클래스란, 객체의 속성과 행위를 정의한 청사진
      - 클래스는 객체를 생성하는데 사용
      - 객체를 생성하기 위해서는 new 연산자를 통한 인스턴스화(인스턴스를 생성하는 것) 과정이 필요함

      ```
      Beverage drink = new Beverage();
      ```

   2. 추상화

      - 구체적인 것을 상세화 하지 않고 공통적인 특성만을 가지고 구성하는 것
      - 있어야할 정보들을 간추려서 구성하는 것

   3. 캡슐화
      - 객체가 내부적으로 기능을 어떻게 구현하는지 감추는 것
      - 객체의 속성과 행위를 하나로 묶은 뒤, 실제 구현 내용의 일부를 접근지정자를 통해 은닉함
      - 외부에서 데이터를 잘못 사용하더라도 객체가 손상되지 않게 해줌
      - 내부 기능 구현이 변경되더라도 그 기능을 사용하는 코드는 영향을 받지 않도록 함
   4. 상속
      - 자식 클래스가 부모 클래스의 맴버를 물려받는 것
      - 상위 클래스를 재사용하여 반복되는 코드를 줄일 수 있음
      - 단, 역할이 같지 않은(is A 관계) 클래스를 상속한다면 많은 문제들이 생길 수 있음
        - 역할이 같지 않기 때문에, 쓰이지 않는 클래스나 메소드가 많아 불필요한 증가가 있을 수 있음
        - 상위 클래스에서 정의한 메소드들 하위 클래스에서 사용할 수 없을 수 있음
        - 이러한 문제들 때문에 역할이 같지 않은 클래스의 기능을 재사용 하고 싶다면 조립(composition)을 통해 재사용 하는것이 좋음
          > 조립?
      - 그러므로 상속을 사용할 때는 재사용보다는 <b>기능을 확장</b> 할 때와 역할이 같을 때 사용하는것이 좋음
   5. 다형성
      - 하나의 객체가 여러가지 타입을 가질 수 있는 것
      - 상속으로 인해 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있음(ex. List<> list = new ArrayList<>();)
      - 단, 자식 클래스는 부모 클래스의 인스턴스가 될 수 있지만 부모 클래스는 자식 클래스의 인스턴스가 될 수 없음
      - 대표적인 예시로는 overloading과 overriding이 있음
      - 오버로딩은 메서드 명은 같지만 파라미터가 다른 메서드로, 대표적인 예시로 println() 메서드가 있다
      ```
      System.out.println("String!"); //String 타입
      System.out.println(123); //int 타입
      System.out.println(true); //boolean 타입
      ```
      - 오버라이딩은 상속을 받은 하위 클래스에서 상위 클래스의 메소드를 재정의하는 것을 말함

3. 객체 지향적 설계의 5원칙

   > SOLID

   1. SRP(Single Responsibility Principle)

      - 단일 책임 원칙
      - 클래스는 한개의 책임(기능)을 가져야 함
      - 이를 지키지 않을 경우, 한 구간의 변경으로 인해 관련된 다른 코드가 변경될 가능성이 높음

   2. OCP(Open-Closed Principle)

      - 개방-폐쇄 원칙
      - 확장에는 열려있어야 하며, 변경에는 닫혀있어야 함
      - 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있어야 함

   3. LSP(Liskov Substitution Principle)

      - 리스코프 치환 원칙
      - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 함
      - 상속 관계로 묶일 수 없는 클래스들(역할이 다른 클래스)들을 상속 관계로 묶으면 이 원칙에 어긋남

   4. ISP(Interface Segregation Principle)

      - 인터페이스 분리 원칙
      - 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 함
      - 자신이 이용하지 않는 메서드에 의존하지 않아야 함
      - 하나의 일반적인 클래스 보다는, 여러개의 구체적인 인터페이스가 더 나음

   5. DIP(Dependency Inversion Principle)
      - 의존 역전 원칙
      - 고수준 모듈은 저수준 모듈의 구현에 의존해선 안 됨
      - 저수준 모듈이 변경되더라도 고수준 모듈은 변경 할 필요 없어야 함

4. 객체 지향 프로그래밍의 장단점

   1. 장점

      - 다른 클래스를 가져와서 이용할 수 있고, 상속을 통해 확장할 수 있어 <b>코드 재사용이 용이함</b>
      - 코드를 수정하더라도 캡슐화를 통해 주변에 영향이 적게 가기 때문에<b>유지보수가 쉬움</b>
      - 독립적인 객체를 재사용 할 수 있어 <b>생산성 향상</b>

   2. 단점
      - 처리 속도가 상대적으로 느림
      - 객체가 많으면 용량이 커질 수 있음
      - 객체가 처리하려는 것에 대한 정확한 이해가 필요하기 때문에 설계시 많은 시간과 노력이 필요
      - 객체가 상태를 가지고 있음. 객체에는 변수가 존재하며 이 변수를 통해 객체가 예측할 수 없는 상태를 갖게 되어 어플리케이션 내부에서 버그를 발생시킴 (-> 이를 개선한 것이 함수형 프로그래밍)
